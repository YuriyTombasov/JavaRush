Привет, Амиго! Сегодня я расскажу тебе, что же такое «адаптер». Надеюсь, что после его изучения ты начнешь понимать потоки ввода-вывода гораздо лучше.

image-ru-19-01
Представь, что в твоей программе ты используешь два фреймворка, написанные другими программистами/компаниями. Оба фреймворка очень хорошие и используют принципы ООП: абстракцию, полиморфизм, инкапсуляцию. Они вместе практически полностью покрывают задачи твоей программы. За тобой осталось простая задача — объекты, которые создает один фреймворк нужно передать во второй. Но оба фреймворка совершенно разные и «не знают друг о друге» — т.е. не имеют общих классов. Тебе нужно как-то преобразовывать объекты одного фреймворка в объекты другого.

Эту задачу можно красиво решить, применив подход (паттерн проектирования) «адаптер»:

Код на Java	Описание
class MyClass implements Interface2
{
 private Interface1 object;
 MyClass(Interface1 object)
 {
  this.object = object;
 }
 // тут располагаются методы Interface2,
 // которые вызывают методы Interface1
}
Это схематическое описание «паттерна проектирования адаптер».
Суть его в том, что класс MyClass является преобразователем (адаптером) одного интерфейса к другому.

— А можно более конкретный пример?

— Ок. Допустим, что у каждого фреймворка есть свой уникальный интерфейс «список», вот как это может выглядеть:

Код на Java	Описание
interface AlphaList
{
 void add(int value);
 void insert(int index, int value);
 int get(int index);
 void set(int index, int value);
 int count();
 void remove(int index);
}
Код из первого(Alpha) фреймворка.
AlphaList – это один из интерфейсов, для взаимодействия кода фреймворка и кода, который будет использовать этот фреймворк.

class AlphaListManager
{
 public static AlphaList createList()
 {
  //какой-то код по созданию объекта
 }
}
AlphaListManager – класс фреймворка, метод которого createList создает объект типа AlphaList
interface BetaList
{
 int getValue(int index);
 void setValue(int index, int value);
 int getSize();
 void setSize(int newSize);
}
class BetaSaveManager
{
 public static void saveList(BetaList list)
 {
  //какой-то код по сохранению объекта
  //типа BetaList в файл на диске
 }
}
Код из второго(Beta) фреймворка.
BetaList – это один из интерфейсов, для взаимодействия кода фреймворка и кода, который будет использовать этот фреймворк.

BetaSaveManager – класс фреймворка, метод которого saveList сохраняет на диск объект типа BetaList

class ListAdapter implements BetaList
{
 private AlphaList list;
 ListAdapter(AlphaList list)
 {
  this.list = list;
 }

 int getValue(int index)
 {
  return this.list.get(index);
 }

 void setValue(int index, int value)
 {
  this.list.set(index, value);
 }

 int getSize()
 {
  return this.list.count();
 }

 void setSize(int newSize)
 {
  if (newSize > this.list.count()
  {
   while (this.list.count() < newSize)
  {
   this.list.add(null);
  }
 }
 else if (newSize < this.list.count() {
   while (this.list.count() > newSize)
   {
    list.remove(list.count() - 1);
   }
  }
 }
}
Класс «адаптер» (т.е. переходник) от интерфейса AlphaList к интерфейсу BetaList
Класс ListAdapter реализует интерфейс BetaList из второго фреймворка.

Когда кто-то вызывает эти методы, код класса перевызывает методы переменной list, которая имеет тип AlphaList из первого фреймворка.

Объект типа AlphaList передается в конструктор ListAdapter в момент создания

Метод setSize работает по принципу: если нужно увеличить размер списка – добавим туда пустых (null) элементов. Если нужно уменьшить – удалим несколько последних.

public static void main(String[] args)
{
 AlphaList listAlpha = AlphaListManager.createList();
 BetaList listBeta = new ListAdapter(listAlpha);
 BetaSaveManager.saveList(listBeta);
}
Пример использования
— Больше всего понравился пример использования. Очень компактно и понятно.........

------------------------------------------------
-------------------------------------------------

Reader/Writer
Java Core
9 уровень, 2 лекция
— Привет, Амиго! Сегодня Элли тебе рассказала про паттерн адаптер.

Большинство классов, относящихся к потокам ввода-вывода, реализовано в виде адаптера. Они преобразуют либо равнозначные интерфейсы, либо соединяют их по принципу от простого к сложному.

— А InputStreamReader и BufferedReader – тоже адаптеры? По крайней мере, они очень похожи на них по стилю использования: объект после создания передается в конструктор другого объекта.

— Да, InputStreamReader преобразует интерфейс InputStream к интерфейсу Reader. BufferedReader не адаптер в чистом виде, т.к. разработчики Java решили не выделять его методы в отдельный интерфейс. Но по духу, он стоит очень близко к ним.

Вместо того, чтобы писать 100500 различных классов, разработчики Java написали два десятка адаптеров и разрешили их соединять друг с другом, как программисту захочется.

Такой подход очень удобен. Программист всегда может написать свой класс и/или адаптер, реализовать в нем стандартный интерфейс и включить его в собранную им цепочку объектов-адаптеров.

— Так вот как оно, оказывается, все устроено. Вместо больших сложных классов – цепочки простых объектов и адаптеры. А ты просто создаешь их и соединяешь в правильном порядке!

— И реализовываешь то, чего не хватает.

— Да, я понимаю.

— Но вообще-то я хотел сегодня рассказать тебе про Reader и Writer. Это два абстрактных класса, которые очень похожи на классы InputStream и OutputStream. Но в отличие от них, эти два класса работают с символами. Они читают символы и записывают символы. Они очень удобны при работе с текстовой информацией. Давай посмотрим, какие методы у них есть:

Методы класса Reader	Что метод делает
int read(char[] cbuf);
— метод сразу читает много символов в буфер (массив символов), пока буфер не заполнится или не закончатся символы там, откуда он их читает.
Метод возвращает количество реально прочитанных символов (оно может быть меньше длины массива)
int read();
— метод читает один символ и возвращает его как результат. Результат расширяется до int, для красоты. Если доступных символов нет, метод вернет «-1».
boolean ready();
— метод возвращает true если есть еще непрочитанные символы для методов read
void close();
— метод «закрывает» поток, вызывается после окончания работы с потоком.
Объект выполняет служебные операции, связанные с закрытием файла на диске и т.д.
Из потока больше нельзя читать данные.
— Оказывается, благодаря методу read(char[] cbuf) из Reader’а можно читать символы целыми блоками, а не по одному символу. Так и быстрее и удобнее.

— Да. А теперь посмотрим, какие методы есть у Writer:

Метод	Что метод делает
void write(int c);
— метод записывает один символ. Тип int сужается до char, лишняя часть просто отбрасывается.
void write(char[] cbuff);
— метод записывает массив символов.
void write(String s);
— метод записывает строку. Она просто преобразовывается в массив символов и вызывается второй метод.
void flush();
— если есть данные, которые хранятся где-то внутри и еще не записаны, то они записываются.
void close();
— метод «закрывает» поток – вызывается после окончания работы с потоком.
Объект выполняет служебные операции, связанные с закрытием файла на диске и т.д.В поток больше нельзя писать данные, flush при этом вызывается автоматически.
Важно понять, что Reader и Writer – это абстрактные классы. Они ничего не делают и практически не содержат кода. Все их методы должны будут реализовываться в классах, которые будут унаследованы от них. Их же задача – стандартизировать механизм взаимодействия между классами. Разработчикам не нужно изобретать свои стандарты для взаимодействия друг с другом. Гораздо удобнее всем поддерживать несколько базовых стандартов. Тогда классы, написанные разными программистами, смогут легко взаимодействовать не только с классами, написанными разработчиками Java, но и с классами других программистов.

Стандарты – великая сила.

— Согласен. Поддержка общих стандартов – благо для всех.


-------------------------------------                                    
------------------------------------


FileReader/FileWriter
Java Core
9 уровень, 4 лекция
— Привет, Амиго! Вчера Риша рассказывал тебе про FileInputStream, FileOutputStream. А сегодня я расскажу тебе о классах FileReader и FileWriter.

Как ты уже, наверное, догадался, все эти классы являются адаптерами между объектом File и “интерфейсами” InputStream, OutputStream, Reader, Writer.

— Они похожи на адаптеры между File и Reader/Writer, вот только в конструктор к ним нужно передать объект String, а не File!

— На самом деле, у них несколько конструкторов: есть и File и String. И если ты передашь в конструктор класса объект типа String, то в нем, незаметно для тебя создастся объект типа File, с путем файла, взятым из переданного String.

Это сделано для удобства. Разработчики Java взяли самые частые сценарии использования этих классов, и написали для всех их конструкторы. Это очень удобно, не так ли?

— Да, удобно, согласен. Но почему тогда мне постоянно приходится писать:
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
Почему они не добавили этот сценарий?

— Дело в том, что типичная программа на Java не работает с консолью. Вернее, почти никогда ничего с нее не читает. Это может быть web-сервер, сервер приложений или еще какая-нибудь сложная система.

Но для вывода данных и текста на консоль добавили объект PrintStream. Так как те же «серверные программы» часто пишут в консоль свое состояние работы, ошибки и еще разную информацию.

— Понятно. А копировать файл с помощью FileReader и FileWriter тоже можно?

— Да, если он текстовый (т.е. состоит из символов). Вот, смотри пример:

 Копируем файл на диске
public static void main(String[] args) throws Exception
{
 FileReader reader = new FileReader("c:/data.txt");
 FileWriter writer = new FileWriter("c:/result.txt");

 while (reader.ready()) //пока есть непрочитанные байты в потоке ввода
 {
  int data = reader.read(); //читаем один символ (char будет расширен до int)
  writer.write(data); //пишем один символ (int будет обрезан/сужен до char)
 }

 //закрываем потоки после использования
 reader.close();
 writer.close();
}
— Почти никаких отличий.

— Да, отличия минимальны.


-------------------------------------
--------------------------------------


BufferedReader/InputSreamReader
Java Core
9 уровень, 6 лекция
— Привет, Амиго! Ты уже давно пользуешься классами BufferedReader и InputStreamReader. Теперь давай разберемся, что же они делают.

Класс InputStreamReader является классическим адаптером от интерфейса InputStream к интерфейсу Reader. Тут даже и добавить нечего.

Но в вкратце, происходит вот что. Когда ты запрашиваешь (читаешь посредством read) у объекта типа InputStreamReader очередной символ, он читает из переданного ему в конструктор InputStream-а несколько байт и возвращает их как один char.

Но Reader – не самый удобный объект для работы. Нам часто нужно прочитать не все введенные пользователем символы за один раз, а разбить эти символы на строки.

— Но у класса Reader ведь есть метод read(CharsetBuffer s), разве мы не можем использовать его?

— Этот метод читает данные куском, размер которого равен размеру буффера и помещает их в объект CharsetBuffer.

Текст обычно делится на строки (линии, line — строка по-английски). Поэтому метод read(CharsetBuffer s) может прочитать несколько «линий» за один раз. Если же нам нужно прочитать текст именно до конца «линии» (т.е. все символы строки до enter), для этого лучше поискать что-нибудь еще. И такой метод есть. В классе BufferedReader.

Класс BufferedReader, являющийся удобной надстройкой над Reader, имеет один очень удобный метод: readLine(). Этот метод позволяет читать из Reader-а сразу целыми строками (т.е. линиями). Когда ты в своем коде вызываешь метод readLine, он читает из объекта Reader символы, пока не встретится enter. Как только enter встретится, метод склеит символы в одну строку и вернет ее.

— Я этим постоянно пользовался, только не знал как все это работает. Теперь знаю. Спасибо, Ким.


----------------------------------------
---------------------------------------


Пишем свой ридер-обертку на System.out
Java Core
9 уровень, 7 лекция
— Привет, Амиго! Сегодня я расскажу как сделать новую интересную штуку — подменить объект System.out.
System.out — это статическая переменная out типа PrintStream в классе System. Эта переменная имеет модификатор final, так что просто так новое значение ей не присвоить. Но класс System имеет для этого специальный метод setOut(PrintStream stream). Им то мы и воспользуемся.

— Интересно. А на что мы его заменим?

— Нам нужен какой-то объект, куда можно будет собирать выведенные данные. Лучше всего на эту роль подойдет ByteArrayOutputStream. Это специальный класс, который с одной стороны является динамическим (растягиваемым) массивом, а с другой – реализует интерфейс OutputStream.

— Адаптер между массивом и OutputStream?

— Что-то вроде того. Вот как будет выглядеть наш код.

Код
public static void main(String[] args) throws Exception
{
 //запоминаем настоящий PrintStream в специальную переменную
 PrintStream consoleStream = System.out;

 //Создаем динамический массив
 ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
 //создаем адаптер к классу PrintStream
 PrintStream stream = new PrintStream(outputStream);
 //Устанавливаем его как текущий System.out
 System.setOut(stream);

 //Вызываем функцию, которая ничего не знает о наших манипуляциях
 printSomething();

 //Преобразовываем записанные в наш ByteArray данные в строку
 String result = outputStream.toString();

 //Возвращаем все как было
 System.setOut(consoleStream);
}

public static void printSomething()
{
 System.out.println("Hi");
 System.out.println("My name is Amigo");
 System.out.println("Bye-bye!");
}
— А что мы будем делать с полученной строкой?

— Да что угодно. Можем, например, развернуть ее задом наперед. Тогда это будет выглядеть так:

Код
public static void main(String[] args) throws Exception
{
 //запоминаем настоящий PrintStream в специальную переменную
 PrintStream consoleStream = System.out;

 //Создаем динамический массив
 ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
 //создаем адаптер к классу PrintStream
 PrintStream stream = new PrintStream(outputStream);
 //Устанавливаем его как текущий System.out
 System.setOut(stream);

 //Вызываем функцию, которая ничего не знает о наших манипуляциях
 printSomething();

 //Преобразовываем записанные в наш ByteArray данные в строку
 String result = outputStream.toString();

 //Возвращаем все как было
 System.setOut(consoleStream);

 //разворачиваем строку
 StringBuilder stringBuilder = new StringBuilder(result);
 stringBuilder.reverse();
 String reverseString = stringBuilder.toString();

 //выводим ее в консоль
 System.out.println(reverseString);
}

public static void printSomething()
{
 System.out.println("Hi");
 System.out.println("My name is Amigo");
 System.out.println("Bye-bye!");
}
— Как интересно. Теперь я начинаю понемногу понимать, какие большие возможности дают эти маленькие классы.
Спасибо за интересный урок, Билаабо.
