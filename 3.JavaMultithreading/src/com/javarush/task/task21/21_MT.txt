Приоритет операторов

1) Группа «математические операторы»
Обозначение	Пример	Название		Описание (что делает)
+		a + b	Оператор сложения	Складывает два числа.
-		c - d	Оператор вычитания	Вычитает второе число из первого.
*		a * t	Оператор умножения	Умножает два числа.
/		a / b	Оператор деления	Делит первое число на второе.
%		c % d	Остаток от деления	Вычисляет остаток от деления первого числа на второе.
-		-a	Одинарный минус		Меняет знак переменой наобратный.Плюс на минус, минус на плюс.
+		+a	Одинарный плюс		Ничего не меняет. Добавлен вместе с одинарным минусом для красоты.



2) Группа «операторы сравнения»
Обозначение	Пример	Название		Описание (что делает)
<		a < b	Меньше			Проверяет, что a меньше b.
<=		c <= d	Меньше или равно	Проверяет, что c меньше или равно d.
>		a > b	Больше			Проверяет, что a больше b.
>=		c >= d	Больше или равно	Проверяет, что c больше или равно d.
==		i == j	Равно			Проверяет, что i равно j.
!=		a != 0	Неравно			Проверяет, что a неравно нулю.



3) Группа «логические операторы»
Обозначение	Пример		Название		Описание (что делает)
&&		a && b		AND – «и»		Результат выражения true, только когда и a и b равны true.
||		c || d		OR – «или»		Результат выражения true, если a или b равно true. Оба или хотя бы один.
!		!a		NOT – «не»		Результат выражения true, только если a равно false.


4) Группа – «побитовые операторы»
Обозначение	Пример		Название		Описание (что делает)
&		a & b		AND – «и»		Побитовое «И»
|		c | d		OR – «или»		Побитовое «ИЛИ»
~		~a		NOT – «не»		Побитовое «НЕ»
^		a^b		XOR – «исключающее или»	Побитовое «ИСКЛЮЧАЮЩЕЕ ИЛИ»

— Побитовые операторы выполняю операцию над целыми числами побитово.
— Каждое число представляется в виде набора бит, а затем вычисляется результат по такой схеме:
Если первый бит в обоих числах равен 1, то первый бит результата будет 1.
Если второй бит в обоих числах равен 1, то второй бит результата будет 1. И так далее

Бит может принимать только два значения – 0 и 1
представь, что 1 – это true, а 0 – это false. Тогда операции над отдельными битами будут практически такими же, как и логические операции:

Логическое выражение	Битовое выражение
true && true == true	1&1 == 1
true && false == false	1&0 ==0
true || true == true	1|1 ==1
true || false == true	1|0 ==1
false || false = false	0|0 ==0
!false == true		~0 ==1
!true == false		~1 == 0

XOR - когда значение разные – истина (true, 1), когда одинаковые – (false, 0)
Логическое выражение		Битовое выражение
true XOR true == false		1 ^ 1 ==0
false XOR false == false	0 ^ 0 ==0
true XOR false == true		1 ^ 0 ==1
false XOR true == true		0 ^ 1 ==1

Вот тебе еще пара примеров побитовых операций:
Пример	Числа в битовом виде	Ответ в битовом виде	Ответ
5 & 3	00000101 & 00000011	00000001		1
7 & 2	00000111 & 00000010	00000010		2
5 | 9	00000101 | 00001001	00001101		13
5 ^ 9	00000101 ^ 00001001	00001100		12
~9	~00001001		11110110		246



5) Группа «операторы сдвига»
Обозначение	Пример		Название				Описание (что делает)
>>		a>>b		сдвиг вправо				Сдвигает биты числа a, на b разрядов вправо.
<<		c<<d		сдвиг влево				Сдвигает биты числа c, на d разрядов влево.
>>>		a>>>2		сдвиг вправо с заполнением нулем	Сдвигает биты числа a, на 2 разряда вправо.

Пример	Числа в битовом виде	Ответ в битовом виде	Ответ
10>>1	00001010>>1		00000101		5
10>>2	00001010>>2		00000010		2
10<<1	00001010<<1		00010100		20
10<<2	00001010<<2		00101000		40

Сдвига разрядов числа на 1 влево – то же самое, что умножить число на 2. На два разряда равно умножению на 4, на три разряда – умножению на 8 и так далее.
Сдвиг вправо – соответственно, деление на 2,4,8,16,…
— А в чем отличие операторов «>>>» и «>>»?
— Они отличаются при работе с отрицательными числами. Дело в том, что знак отрицательного числа хранится в крайнем левом бите. И при сдвиге вправо число перестает быть отрицательным.
Поэтому и придумали два различных оператора, вот смотри:

Выражение	Результат	Описание
10001010>>1	11000101	Отрицательное число остается отрицательным.Новые разряды заполняются 1, для отрицательных чисел.
10001010>>2	11100010
10001010>>3	11110001
10001010>>>1	01000101	Отрицательное число перестает быть отрицательным. Новые разряды заполняются 0, для отрицательных чисел.
10001010>>>2	00100010
10001010>>>3	00010001	Сдвиг не циклический. Биты, которые оказались за краем числа слева или справа, просто отбрасываются.



6) Группа «операторы присваивания»
Оператор	Что он значит
a += b;		a = a + b;
a -= b;		a = a - b;
a *= b;		a = a * b;
a %= b;		a = a % b;
a |= b;		a = a | b;
a &= b;		a = a & b;



7) Группа «операторы инкремента и декремента»
Запись		Пример		Описание
++		a++;++b;	Увеличивает число на 1.
--		d--;--i;	Уменьшает число/переменную на 1.

Если переменная с таким оператором участвует в каком-нибудь выражении или присваивании, то тут возникают различия. Давай я лучше покажу тебе на примере:
Пример				Что происходит на самом деле			Описание
int a = 3;int b = ++a;		int a = 3;a=a+1;int b = a;			а сначала увеличивается на 1, затем участвует в выражении.
int a = 3;int b = a++;		int a = 3;int b = a;a=a+1;			а сначала участвует в выражении, затем увеличивается на 1.
int a = 3;return a++;		int a = 3;int result = a;a=a+1;return result;	функция вернет 3, но значение a будет увеличено на 1.
int x = 5;x = ++x + ++x;	int x = 5;int a=x+1;//первое слагаемое 6
				x = a;int b=x+1;//второе слагаемое 7
				x = b;x = a + b;				тут будет ответ 13. Сначала x увеличится на 1, и это значение подставится на место первого слагаемого, а потом х увеличится еще раз на 1.


8) Группа «тернарный оператор»
В этом операторе участвуют не одна переменная/выражение и не две, а сразу три:

Вот как он записывается			А вот чему он эквивалентен:
a ? b : c;				if (a) b else c
int min = a < b ? a : b;		if (a<b) min = a; else min = b;
return a!=null ? a.length : 0;		if (a!=null) return a.length; else return 0;



9) Группа «остальное»
Запись			Пример				Описание
()			(a+b)*c				Скобки повышают приоритет выполнения.Сначала выполняется то, что в скобках.
[]			c[i] = c[i+1];			Получение элемента массива по индексу.
.			int n = a.length;		«оператор точка» – получение переменных и методов у объекта.



################## ПРИОРИТЕТ #####################
Операторы		Примеры	
()			(a+b)
[]			c[i] = c[i]+1
.			
++			i++; ++i;
--			--j; a--;
~			~c
!			!f
+			return +a;
-			return -a;
*			a * b
/			c / d
%			a % b
+			a+b
-			c-d String s = "count"+"35 ";
>>			a>>3
<<			b<<2
>>>			c>>>3
<			a < b
<=			a <= b
>			c > b
>=			c >= b
==			a == 3
!=			a != 0
&			a & 7
^			a ^ b
|			a | b
&&			(a<b) && (a<c)
||			(b!=0) || (c!=0)
? : =			a>0 ? a : -a;
=
*=, /=, %=
-=, +=
<<=. >>=, >>>=
&=, ^=. |=	 




===================================================================================3====
Все методы класса Object, метод toString()


Метод	Описание
public String toString() 			Возвращает строковое представление объекта.
public native int hashCode()
public boolean equals(Object obj)		Пара методов, которые используются для сравнения объектов.
public final native Class getClass()            Возвращает специальный объект, который описывает текущий класс.
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout)
public final void wait(long timeout, intnanos)
public final void wait()                        Методы для контроля доступа к объекту из различных нитей. Управление синхронизацией нитей.
protected void finalize()                       Метод позволяет «освободить» родные не-Java ресурсы: закрыть файлы, потоки и т.д.
protected native Object clone()                 Метод позволяет клонировать объект: создает дубликат объекта.


toString();
Этот метод позволяет получить текстовое описание любого объекта. Реализация его в классе Object очень простая:
return getClass().getName() + "@" + Integer.toHexString(hashCode());
getClass() и hashCode() – это тоже методы класса Object.
Вот стандартный результат вызова такого метода  java.lang.Object@12F456
Но ценность данного метода в другом. Данный метод можно переопределить в любом классе и возвращать более нужное или более детальное описание объекта.
Но и это еще не все. Благодаря тому, что для каждого объекта можно получить его текстовое представление, в Java можно было реализовать поддержку «сложения» строк с объектами.

=============================================================================================4=====================
Методы equals & hashCode: зачем, где используются, как работают

Цель метода equals – определить идентичны ли объекты внутри, сравнив внутреннее содержание объектов. - И как он это делает?
У класса Object есть своя реализация метода equals, которая просто сравнивает ссылки:
public boolean equals(Object obj)
{
return (this == obj);
}

Этот метод создавался, чтобы разработчики переопределяли его в своих классах. Ведь только разработчик класса знает, какие данные важны, что учитывать при сравнении, а что – нет.

Пример
class Дробь
{
private int числитель;
private int знаменатель;Дробь(int числитель, int знаменатель)
{
this.числитель = числитель;
this.знаменатель = знаменатель;
}public boolean equals(Object obj)
{
if (obj==null)
return false;

if (obj.getClass() != this.getClass() )
return false;

Дробь other = (Дробь) obj;
return this.числитель* other.знаменатель == this.знаменатель * other.числитель;
}
}

Теперь разберем пример.
Мы переопределили метод equals, и теперь для объектов класса Дробь у него будет своя реализация.
В этом методе есть несколько проверок:
1) Если переданный для сравнения объект – null, то объекты не равны. Объект, у которого вызвали метод equals ведь точно не null.
2) Проверка на сравнение классов. Если объекты разных классов, то мы не будем пробовать их сравнить, а сразу говорим, что это различные объекты – return false.
3) в третьей части метода equals мы преобразуем переданный объект к типу Дробь и сравниваем дроби.

Да, но это только половина дела. Есть еще второй метод – hashCode()
Метод hashCode нужен для быстрого сравнения.
У метода equals есть большой минус – он слишком медленно работает. Допустим, у тебя есть множество(Set) из миллиона элементов, и нам нужно проверить, содержит ли оно определенный объект или нет.
Метод hashCode() для каждого объекта возвращает определенное число. Какое именно – это тоже решает разработчик класса, как и в случае с методом equals.

Давай рассмотрим ситуацию на примере:
Представь, что у тебя есть миллион 10-тизначных чисел. Тогда в качестве hashCode для каждого числа можно выбрать остаток от его деления на 100.
Пример:
Число		Наш hashCode
1234567890	90
9876554321	21
9876554221	21
9886554121	21
Вместо того чтобы сравнивать числа, мы будем сравнивать их hashCode. Так быстрее.
И только если hashCode-ы равны, сравнивать уже посредством equals.
- Да, так быстрее. Но нам все равно придется сделать миллион сравнений, только уже более коротких чисел, а для тех чисел, чьи hashCode совпадают, опять вызвать equals.
- Нет, можно обойтись гораздо меньшим числом.
Представь, что наше множество хранит числа, сгруппированные по hashCode или отсортированные по hashCode.
Тогда можно очень быстро и легко отбросить ненужные группы, достаточно один раз для каждой группы проверить совпадает ли ее hashCode с hashCode заданного объекта.

Разработчик, который реализует функцию hashCode, должен знать следующие вещи:
А) у двух разных объектов может быть одинаковый hashCode
Б) у одинаковых объектов (с точки зрения equals) должен быть одинаковый hashCode.
В) хеш-коды должны быть выбраны таким образом, чтобы не было большого количества различных объектов с одинаковыми hashCode. Это сведет все их преимущество на нет.
!!! И теперь самое важное. Если ты переопределяешь метод equals, обязательно нужно переопределить метод hashCode(), с учетом трех вышеописанных правил.

Все дело в том, что коллекции в Java перед тем как сравнить объекты с помощью equals всегда ищут/сравнивают их с помощью метода hashCode().
И если у одинаковых объектов будут разные hashCode, то объекты будут считаться разными - до сравнения с помощью equals просто не дойдет.

======================================================================================6====
wait, notify, notifyAll

Эти методы были придуманы как часть механизма синхронизации нитей.

Напомню, что в Java есть встроенный механизм управления доступом к общим ресурсам (объектам) из разных нитей.
Нить может объявить какой-нибудь объект занятым, и другие нити будут вынуждены ждать, пока занятый объект не освободиться.
— Я помню, это делается с помощью ключевого слова synchronized.
— Правильно. Обычно такой код выглядит примерно так:

public void print()
{
 Object monitor = getMonitor();
 synchronized(monitor)
 {
  System.out.println("text");
 }
}

— Ага. Если две нити одновременно вызовут метод print(), то одна из них войдет в блок, помеченный synchronized, и заблокирует monitor, поэтому вторая нить будет ждать, пока монитор не освободится.
— Правильно. Как только нить входит в блок, помеченный synchronized, то объект-монитор помечается как занятый, и другие нити будут вынуждены ждать освобождения объекта-монитора.
Один и тот же объект-монитор может использоваться в различных частях программы.
— Монитором принято называть объект, который хранит состояние занят/свободен.
Вот тут и вступают в дело методы wait и notify.
Собственно, методов как таковых всего два. Остальные – это лишь модификации этих методов.
Теперь разберемся, что же такое метод wait и зачем он нужен.

Иногда в программе может оказаться такая ситуация, что нить вошла в блок кода synchronized, заблокировала монитор и не может работать дальше, т.к. каких-то данных еще не хватает:
например, файл который она должна обработать еще не загрузился или что-нибудь в таком духе.
Мы же можем просто подождать, когда файл скачается. Можно просто в цикле проверять – если файл еще не скачался – спать, например, секунду и опять проверять и т.д.
Примерно так:
while(!file.isDownloaded())
{
 Thread.sleep(1000);
}
processFile(file);

Но в нашем случае такое ожидание слишком дорого. Т.к. наша нить заблокировала монитор, то другие нити вынуждены тоже ждать, хотя их данные для работы могут быть уже готовы.
Для решения этой проблемы и был придуман метод wait(). Вызов этого метода приводит к тому, что нить освобождает монитор и «становится на паузу».
Метод wait можно вызвать у объекта-монитора и только тогда, когда это монитор занят – т.е. внутри блока synchronized.
При этом нить временно прекращает работу, а монитор освобождается, чтобы им могли воспользоваться другие нити.
Часто встречаются ситуации, когда в блок synchronized зашла нить, вызвала там wait, освободила монитор.
Затем туда вошла вторая нить и тоже стала на паузу, затем третья и так далее.
— А как же нить снимется с паузы?
— Для этого есть второй метод – notify.
Методы notify/notifyAll можно вызвать у объекта-монитора и только, когда этот монитор занят – т.е. внутри блока synchronized.
Метод notifyAll снимает с паузы все нити, которые стали на паузу с помощью данного объекта-монитора.
Метод notify «размораживает» одну случайную нить, метод notifyAll – все «замороженные» нити данного монитора.

Есть еще модификации метода wait():
Метод wait()				Пояснение
void wait(long timeout)         	Нить «замерзает», но через переданное количество миллисекунд автоматически «размораживается».
void wait(long timeout, int nanos)      Нить «замерзает», но через переданное количество миллисекунд и наносекунд автоматически «размораживается».


==============================================================================7
Метод clone, интерфейс Cloneable

Цель этого метода – клонировать объект – т.е. создать его клон/копию/дубликат.
Если его вызвать, то Java-машина создаст и вернет дубликат объекта, у которого вызвали этот метод.
Клонирование объекта в классе Object реализовано очень примитивно – при клонировании создается всего один новый объект: просто создается еще один объект и его полям присваиваются значения полей объекта-образца.
Если копируемый объект содержит ссылки на другие объекты, то ссылки будут скопированы, дубликаты тех объектов не создаются.

Дело в том, что Java-машина не знает, какие объекты можно клонировать, а какие нет. Файлы, например, клонировать нельзя. Как и поток System.in.
Поэтому вопрос о полноценном клонировании был отдан на откуп разработчикам классов. Тут все было сделано по аналогии с методом equals. Даже есть свой аналог hashCode – это интерфейс Cloneable.
Интерфейс Cloneable – это так называемый интерфейс-маркер, который не содержит никаких методов. Он используется, чтобы маркировать (помечать) некоторые классы.
Если разработчик класса считает, что объекты класса можно клонировать, он помечает класс этим интерфейсом (наследует класс от Cloneable).
Если разработчика не устраивает стандартная реализация метода clone, он должен написать свою, которая будет создавать дубликат объекта правильным образом.
При вызове метода clone(), Java проверяет, был ли у объекта интерфейс Cloneable. Если да — клонирует объект методом clone(), если нет — выкидывает исключение CloneNotSupportedException.
Метод clone() объявлен как protected, так что он доступен для вызова только классам из его пакета (java.lang.*) или классам-наследникам.

Если ты хочешь воспользоваться «клонированием по умолчанию», которое реализовано в классе Object, тебе нужно:
а) Добавить интерфейс Cloneable своему классу
б) Переопределить метод clone и вызвать в нем базовую реализацию:
class Point implements Cloneable
{
 int x;
 int y;

 public Object clone()
 {
  return super.clone();
 }
}


Или ты можешь написать реализацию метода clone полностью сам:
class Point
{
 int x;
 int y;

 public Object clone()
 {
  Point point = new Point();
  point.x = this.x;
  point.y = this.y;
  return point;
 }
}


==========================================================================
Метод finalize, интерфейс closeable, try-with-resources(java7)

finalize() – это специальный метод, который вызывается у объекта перед тем, как сборщик мусора его уничтожит.
Основная цель этого метода – освободить используемые внешние не-Java ресурсы: закрыть файлы, потоки ввода-вывода и т.п.
К сожалению, этот метод не оправдывает возложенных на него надежд. Java-машина может отложить уничтожение объекта, как и вызов метода finalize на сколько угодно.
Более того, она вообще не гарантирует, что этот метод будет вызван. В куче ситуаций ради «оптимизации» он не вызывается.

У Джошуа Блоха хорошо написано об этом методе:
finalize() можно использовать только в двух случаях:
- Проверка/подчистка ресурсов с логированием.
- При работе с нативным кодом, который не критичен к утечке ресурсов.
finalize() замедляет работу GC по очистке объекта в 430 раз
finalize() может быть не вызван

На замену метода finalize в Java 7 появился новая конструкция. Называется она – try-with-resources. Это не совсем замена finalize – скорее альтернативный подход.
Почти как try-catch. Дело в том, что в отличие от метода finalize(), блок finally из конструкции try-
catch-finally вызывается всегда. Этим и пользовались программисты, когда нужно было гарантированно освободить ресурсы, закрыть потоки и т.д.

Пример:

InputStream is = null;
try
{
 is = new FileInputStream("c:/file.txt");
 is.read(…)
}
finally
{
 if (is!=null)
 is.close();
}

Независимо от того, нормально ли отработал блок try, или там возникло исключение, блок finally вызовется всегда, и там можно будет освободить занятые ресурсы.
Поэтому в Java 7 этот подход решили сделать официальным, и вот что из этого вышло:

try(InputStream is = new FileInputStream("c:/file.txt"))
{
 is.read(…)
}

Это специальная конструкция try, называемая try-with-resources (так же как и второй for для коллекций называется foreach).
Обрати внимание – после try следуют круглые скобки, где объявляются переменные и создаются объекты. Эти объекты можно использовать внутри блока try, обозначенного скобками {}.
Когда выполнение команд блока try закончится, независимо от того – нормально оно закончилось или было исключение, для объекта, созданного внутри круглых скобок (), будет вызван метод close();
— А если мне нужно вызвать другой метод при выходе из блока try, где мне его указать?
— Тут все немного тоньше. В Java 7 появился такой интерфейс:
public interface AutoCloseable
{
 void close() throws Exception;
}

Ты можешь унаследовать свой класс от такого интерфейса. И тогда его объекты можно будет использовать внутри try-with-resources.
Только объекты такого типа можно использовать внутри круглых скобок try-with-resources для «автоматического закрытия».
— Т.е. мне нужно будет переопределить метод close и написать в нем код по «очистке» моего объекта, а указать другой метод нельзя?
— Ага. Зато можно указывать несколько объектов, разделив их точкой с запятой:

try(
InputStream is = new FileInputStream("c:/file.txt");
OutputStream os = new FileOutputStream("c:/output.txt")
)
{
 is.read(…)
 os.write(…);
}


=================================================================================
Метод getClass(), объект класс, знакомство с Reflection

У каждого объекта есть класс. Но вернемся к объектам. Некоторые объекты полностью содержат какую-то сущность, другие же просто помогают ей управлять.
Ко вторым можно отнести FileOutputStream или Thread. Когда ты создаешь объект Thread, новая нить не создается. Ее создает Java-машина после вызова метода start(). Этот объект просто помогает управлять процессом.
Так же и FileOutputStream: файл хранится на диске и его хранением и доступом к нему управляет ОС. Но мы можем взаимодействовать с ним посредством объектов типа File, при опять-таки помощи Java-машины.

Так вот, для взаимодействия с классами есть специальный класс и называется он — Class.
Каждый раз, когда Java-машина загружает в память новый класс, она создает объект типа Class, посредством которого можно получить некоторую информацию о загруженном классе.
К каждому классу и объекту привязан такой «объект класса».
Пример						Описание
Class clazz = Integer.class;                    Получение «объект класса» у класса Integer.
Class clazz = int.class;                        Получение «объект класса» у класса int.
Class clazz = "123".getClass();                 Получение «объект класса» у объекта типа String.
Class clazz = new Object().getClass();          Получение «объект класса» у объекта типа Object.


Код на Java					Описание
Class s = int.class;
String name = s.getName();                      Получить имя класса.
Class s = Class.forName("java.lang.String");    Получить класс по имени.
Object o1 = String.valueOf(1);
Object o2 = 123 + "T";
o1.getClass() == o2.getClass();                 Сравнить классы у объектов.


Есть еще Reflection. Reflection – это очень круто.
Reflection – это способность класса получить информацию о самом себе. В Java есть специальные классы: Field – поле, Method – метод, по аналогии с Class для классов.
Т.к. объект типа Class дает возможность получить информацию о классе, то объект типа Field – получить информацию о «поле класса», а Method – о «методе класса». И вот что с ними можно делать:

Код на Java						Описание
Class[] interfaces = List.class.getInterfaces();        Получаем список «объектов класса» для интерфейсов класса List
Class parent = String.class.getSuperclass();            Получаем «объект класса» родительского класса для класса String
Method[] methods = List.class.getMethods();             Получаем список методов, которые есть у класса List
String s = String.class.newInstance();                  Создаем новый объект класса String
Method m = String.class.getMethod("length");
int length = (int) m.invoke(s)                          Получаем метод length у класса String, вызываем его у строки s


===========================================http://info.javarush.ru/JavaRush_lectures_discussion/2013/10/20/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-21.html
==================
Вопросы к собеседованиям
1	Перечислите методы класса Object
2	Зачем нужны методы equals & hashCode?
3	Что будет, если переопределить equals, но не переопределить hashCode?
4	Зачем нужны методы wait, notify, notifyAll?
5	Как правильно клонировать объект?
6	Зачем нужен метод finalize() и как он работает?
7	В чем отличие final, finally, finalize?
8	Что такое try-with-resources?
9	Чем отличаются методы wait(1000) и sleep(1000)?
10	В чем отличие i++ и ++i ?
