Интерфейсы-маркеры, глубокое клонирование
Java Multithreading
4 уровень, 1 лекция
 image-ru-24-07
— Привет, Амиго!

— Привет, Билаабо!

— Сегодня я расскажу тебе про интерфейсы-маркеры.

Интерфейсы-маркеры – это интерфейсы, которые не содержат методов. Когда класс наследуется от такого интерфейса, то говорят, что он им помечен.

Примеры таких интерфейсов: Cloneable, Serializable, Remote.

Интерфейс Serializable используется, чтобы помечать классы, которые поддерживают сериализацию — как доказательство того, что объекты класса можно автоматически сериализовать и десериализовать.

Интерфейс Remote используется, чтобы обозначать объекты, которые поддерживают удаленный вызов – вызов из другой Java-машины и/или другого компьютера.

Интерфейс Cloneable используется, чтобы помечать классы, которые поддерживают клонирование.

Кстати, о клонировании.

Клонирование делится на два типа – обычное клонирование и глубокое клонирование.

Обычное клонирование – это когда создается дубликат только указанного объекта, без его внутренних объектов.

Глубокое клонирование – это когда создается дубликат объекта, объектов, на которые он ссылается, объектов, на которые ссылаются они и т.д.

Есть очень хороший способ выполнить качественное глубокое клонирование.

Этот способ подходит, даже если разработчики классов забыли пометить его интерфейсом Cloneable. Достаточно, чтобы объекты были сериализуемыми.

Вот что можно сделать:

1) Создать буфер (массив байт) в памяти.

2) Сериализовать в него нужный объект с подобъектами.

3) Десериализовать из буфера копию сохраненной в него группы объектов.

Код
BigObject objectOriginal = new BigObject();

ByteArrayOutputStream writeBuffer = new ByteArrayOutputStream();
ObjectOutputStream outputStream = new ObjectOutputStream(writeBuffer);
outputStream.writeObject(objectOriginal);
outputStream.close();

byte[] buffer = writeBuffer.toByteArray();
ByteArrayInputStream readBuffer = new ByteArrayInputStream(buffer);
ObjectInputStream inputStream = new ObjectInputStream(readBuffer);
BigObject objectCopy = (BigObject)inputStream.readObject();
На первой строчке мы создаем объект objectOriginal, который будем клонировать. Он и все его подобъекты должны поддерживать сериализацию.

На третьей строчке мы создаем ByteArrayOutputStream – массив байт, который будет динамически растягиваться при добавлении к нему новых данных (как ArrayList).

На 4-й строчке мы создаем ObjectOutputStream, который используется для сериализации.

В пятой строчке мы сериализуем объект objectOriginal в массив байт с помощью outputStream и сохраняем его в массив writeBuffer.

На 8-й строчке мы преобразовываем writeBuffer в обычный массив байт. Дальше мы из этого массива будем «читать» наш новый объект.

На 9-й строчке мы оборачиваем buffer в класс ByteArrayInputStream, чтобы из него можно было читать, как из InputStream.

На 10-й строчке передаем объект readBuffer классу ObjectInputStream, для чтения (десериализации) объекта.

На 11-й строчке мы читаем наш объект и преобразуем его к типу BigObject.

Как тебе?

— Красота.

Кстати, когда код раскрашен разными цветами – гораздо легче его понимать.




__________________---------------------------------------------------




Наследование внутренних классов
Java Multithreading
4 уровень, 3 лекция
 image-ru-24-06
— Привет, Амиго!

— Привет, Ким.

— Я хочу рассказать тебе о наследовании внутренних и вложенных классов.

— Я готов.

— На самом деле с наследованием вложенных классов (те, которые со словом static) никаких проблем нет. Они наследуются так же как и обычные классы:

Пример
public class Car
{
 public static class Door
 {

 }
}

public class LamborginiDoor extends Car.Door
{
}
— А мы можем наследовать вложенные классы от вложенных классов, вложенных в другие классы?

— Почему бы и нет?

Пример
public class Car
{
 public static class Door
 {

 }
}

public class Lamborgini extends Car
{
 public static class LamborginiDoor extends Car.Door
 {
 }
}
— Ок, понятно. Просто наследуем как обычные классы, да?

— Да. А вот внутренние классы наследуются не так просто.

При создании внутреннего класса в нем неявно хранится ссылка на объект его внешнего класса и передается она в него в конструкторе.

Поэтому в объект класса, который унаследовался от внутреннего класса, нужно передать нужный объект явно.

Вот как это выглядит:

Код
public class Car
{
 public class Door
 {

 }
}

public class LamborginiDoor extends Car.Door
{
 LamborginiDoor(Car car)
 {
  car.super();
 }
}
В конструктор класса Door нужно неявно передать объект класса Car, это делается с помощью специальной конструкции: «car.super()».

Кстати, если ты попробуешь создать конструктор вообще без параметров, то программа просто не скомпилируется. Немного странно и непривычно, да?

— Ага. Есть пара моментов, но в целом не «rocket science».




-------------------------------------------------------------------


Локальные классы — классы внутри методов
Java Multithreading
4 уровень, 5 лекция
 image-ru-24-05
— Привет, Амиго!

Еще маленькая и небольшая тема – это локальные классы.

Как ты уже видел, классы можно создавать не только в отдельных файлах, но и внутри других классов. Так вот, это еще не все. Классы можно создавать и внутри методов. Такие классы называются локальными. Они работают как обычные внутренние классы, но их можно использовать в пределах того метода, где их объявили.

Внимание на экран:

Пример
class Car
{
 public ArrayList<Car> createPoliceCars(int count)
 {
  ArrayList<Car> result = new ArrayList<Car>();

  class PoliceCar extends Car
  {
   int policeNumber;
   PoliceCar(int policeNumber)
  {
   this.policeNumber = policeNumber;
  }
 }

 for(int i=0; i<count; i++)
  result.add(new PoliceCar(i));
  return result;
 }
}
— А зачем такие классы нужны?

Класс внутри метода, да еще с методами и конструкторами – это очень плохо читаемый код, разве не так?

— Именно так. Ты абсолютно прав.

В методах также можно использовать анонимные внутренние классы. Но есть одно маленькое преимущество у таких классов, из-за чего их довольно-таки часто используют внутри методов.

Класс, объявленный внутри метода, может использовать локальные переменные этого метода:

class Car
{
 public ArrayList<Car> createPoliceCars(int count)
 {
  ArrayList<Car> result = new ArrayList<Car>();

  for(int i=0; i<count; i++)
  {
   final int number = i;
   result.add(new Car()
  {
   int policeNumber = number;
  });
 }
  return result;
 }
}
Но есть одно ограничение – переменные можно только «читать», изменять их нельзя.

Поэтому существует такое ограничение:

Классы, объявленные внутри метода, могут иметь доступ только к тем переменным метода, которые помечены ключевым словом final. В примере выше ты можешь видеть, что я не могу сразу присвоить переменной policeNumber значение переменной i, а сначала сохраняю его в final-переменную number.

— То, что можно использовать переменные метода – это действительно классная штука. Надеюсь, я оценю ее по достоинству. Плохо только, что нельзя менять переменные.

— Почему их нельзя менять, тебе сегодня расскажет Элли, а я пойду пока часок вздремну.

— Спокойной ночи, Ким. Спасибо за интересный урок.




-------------------------------------------------------------------------------

Что происходит на самом деле (Во что превращаются классы компилятором)
Java Multithreading
4 уровень, 7 лекция
 image-ru-24-04
— Привет, Амиго! Вот тебе еще немного информации.

Я уже тебе говорила, что все анонимные классы на самом деле превращаются компилятором в обычные внутренние классы.

— Ага. Я даже помню, что у них имена – это числа: 1, 2, 3 и т.д.

— Именно так. Но вот, еще, какой есть нюанс.

Если класс был объявлен внутри метода и использовал какие-то переменные, то ссылки на них будут добавлены в сгенерированный класс. Смотри сам:

Было:

Исходный пример:
class Car
{
 public ArrayList<Car> createPoliceCars(int count)
 {
  ArrayList<Car> result = new ArrayList<Car>();

  for(int i=0; i<count; i++)
  {
   final int number = i;
   result.add(new Car()
    {
     public String toString()
     {
      return ""+number;
     }
    });
  }
  return result;
 }
}
Результат компиляции:

Что сгенерировал компилятор:
class Car
{
 public ArrayList<Car> createPoliceCars(int count)
 {
  ArrayList<Car> result = new ArrayList<Car>();

  for(int i=0; i<count; i++)
  {
   final int number = i;
   result.add(new Anonymous2 (number));
  }
   return result;
  }

 class Anonymous2
 {
  final int number;
  Anonymous2(int number)
 {
  this.number = number;
 }

  public String toString()
  {
   return ""+number;
  }
 }
}
Понял в чем штука? Внутренний класс не может изменить локальную переменную метода, т.к. к тому времени, когда будет исполняться код этого класса, мы уже можем вообще уйти из метода.

Теперь второй момент. Метод toString() использует переданную переменную. Для этого пришлось:

А) сохранить ее внутри сгенерированного класса

Б) добавить ее в конструктор.

— Понял. Классы, объявленные внутри метода, всегда работают с копией переменных.

— Именно!

— Тогда понятно, почему переменные должны быть final. И почему их нельзя менять. Если на самом деле ты работаешь с копией, а не с оригиналом, то пользователь не поймет, почему не может менять значение переменной, а значит, надо просто ему запретить ее менять.

— Да, мне кажется, что объявление переменных final – это небольшая плата за то, что компилятор за тебя сгенерирует класс, передаст в него и сохранит там все переменные метода, которые ты хочешь использовать.

— Согласен. Все-таки это крутая штука – анонимные локальные классы.

А если я объявлю внутри метода свой локальный класс и буду в нем использовать переменные метода, компилятор их тоже добавит этому классу?

— Да, добавит в класс и его конструктор.

— Я так и думал.




-------------------------------------------------------------
Конструкторы/переменные анонимных иннер классов, final
Java Multithreading
4 уровень, 8 лекция
— Привет, Амиго!

Как ты уже знаешь, у анонимных внутренних классов не может быть конструктора.

— Ага. Это очень неудобно. Конструктор – это очень нужная вещь.

— Как говорится, если нельзя, но очень хочется, то можно.

Вспомни, у статических переменных нет статического конструктора, но есть статический инициализатор – static-блок.

— Ага, я помню.

— Вот точно такой же инициализатор, только не статик, есть у анонимных внутренних классов:

Пример
class Car
{
 public ArrayList<Car> createPoliceCars(int count)
 {
  ArrayList<Car> result = new ArrayList<Car>();

  for(int i=0; i<count; i++)
  {
    final int number = i;
    result.add(new Car()
    {
      int policeNumber;
      {
        policeNumber = number;
      }
    });
  }
  return result;
 }
}
В этот раз я выделила красным цветом код анонимного внутреннего класса, а фиолетовым – его инициализатор – или, фактически, конструктор. Тело «конструктора» есть, а заголовка метода – нет:

Ожидание	Реальность
class Car
{
int policeNumber;
 Car(){
  policeNumber = number;
 }
}
class Car
{
int policeNumber;
{
policeNumber = number;
}
}
Ты можешь объявлять переменные внутри такого класса и инициализировать их внутри инициализатора.

— Отлично, теперь ограничений значительно меньше.

— На этом мы наше знакомство с внутренними классами и закончим. Надеюсь, тебе понравилось.

— Очень. Лекции Ким, Риши, а особенно твои, Элли, были просто бесподобными.

— Льстец! Продолжай…





----------------------------------------------------------------http://wikijava.it-cache.net/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_10_Thinking_in_Java_4th_edition


