Что такое mutable/immutable объекты и зачем они

Объекты, которые после создания можно изменить, называются изменяемыми или mutable.
Объекты, которые после их создания изменить нельзя, называются неизменяемыми или immutable.

— А от чего зависит, можно объект менять или нет?

— Человек, который пишет новый класс, может сделать объекты этого класса неизменяемыми. Например, можно скрыть все setter’ы — у объекта будет только конструктор и getter’ы, а, значит, после создания объекта поменять его уже будет нельзя.

— И какая от этого польза?

— У неизменяемых объектов много полезных свойств. Но можно выделить два, которые характерны практически для всех immutable-объектов:

1) Неизменяемые объекты можно реализовать значительно проще, чем изменяемые.

2) Неизменяемые объекты можно свободно использовать одновременно из разных нитей.

Чаще всего, когда разработчик решает написать immutable класс, он делает две версии этого класса — mutable и immutable.

— А в чем смысл писать два класса вместо одного?

— Иногда так выгоднее, когда неизменяемая версия объекта будет гораздо проще/быстрее чем изменяемая. Тогда и делают две версии. Это почти как ArrayList и LinkedList: оба — списки, но один оптимизирован для одних целей, второй — для других.

— Уже понятнее.

— Бывают также и чисто immutable классы, без их mutable версии.

— А если мне нужно что-то поменять в таком объекте? Что вообще можно сделать с неизменяемым объектом?

— Обычно immutable классы содержат различные методы, которые «как бы» меняют объект, но вместо изменения самого объекта эти методы просто создают новый объект и возвращают его.

Вот тебе несколько примеров:

Код на Java	Описание
String s = "moscow";
String s2 = s.toUpperCase();
В результате s содержит строку «moscow», а s2 — «MOSCOW»
Integer i = 1;
 Integer j = i;
 j++;
Вот что происходит на самом деле:
Integer i = new Integer(1);
Integer j = i;
j = new Integer(i.getInt()+1);
Класс String — это immutable класс. Все объекты типа String — неизменяемые, что, однако, не мешает нам с ними работать. Например, метод toUpperCase() класса String преобразовывает строку в верхний регистр (заменяет все маленькие буквы на большие). Но этот метод не меняет саму строку, а возвращает новую строку, которая идентична первой, только все символы в верхнем регистре (большие).

Класс Integer — это тоже immutable класс. Все объекты типа Integer — неизменяемые. Каждый раз, когда мы изменяем объект Integer, на самом деле создается новый объект.



******************************
Перечисляю все классы, связанные со строками, и говорю, что делают они и все методы

Сегодня мы плотно займемся классом String.

— У класса String 46 методов, сколько из них знаешь ты?

Разработчики Java заметили, что в большинстве своем строки внутри программ существуют в неизменяемом виде, но иногда их все-таки изменяют.
Очень неприятно, когда вы создали строку, сохранили в нее что-то важное, передали в чужой метод, а он ее поменял.
Чтобы такого не происходило, разработчики решили создать два вида строк – изменяемую и неизменяемую.

— Класс String стал отвечать за неизменяемую строку, а класс StringBuilder – за изменяемую. Объекты этих классов легко преобразуются друг в друга.
В большинстве случаев разработчикам программ на Java достаточно просто String, что показывает, что проектировщики Java были правы.

— Т.е. если мне нужна строка – я создаю класс String, а если нужна изменяемая строка – то класс StringBuilder? 

— Да. На самом деле есть еще класс StringBuffer – это копия StringBilder, но все методы которого объявлены synchronized, для того, чтобы к объекту можно было обращаться из разных нитей программы.

— А как же такой пример? Разве тут строка не изменяется?

String s = "cat";
s= s + "-" + s;
— Нет. Тут есть два объекта String: «cat»и «cat-cat». Второй создается на основе первого, но первый объект не меняется. На самом деле тут все еще интереснее.
Вот какой код сгенерирует компилятор, когда будет компилировать твой пример:

String s = "cat";
StrinsBuilder s2 = new StringBuilder(s);
s2.append("-");
s2.append(s);
s = s2.toString();
Т.е. для создания новой строки практически всегда используется StringBuilder, просто иногда всю работу за тебя делает компилятор. Но ведь твой вариант проще, разве нет?

— Да, классно, что в Java такой продвинутый компилятор.

— А теперь пройдемся по методам класса String:

1) Как узнать длину строки?

Метод length возвращает длину строки – количество в ней символов.

Метод(ы)	Пример(ы)
int length();
String s = "Good news everyone!";
int n = s.length();
int n = "Good news everyone!".length();
2) Как получить символ из строки?

Метод charAt возвращает символ строки по его номеру. Нумерация символов начинается с 0.

Метод(ы)	Пример(ы)
char charAt(int index)
String s = "Good news everyone!";
char n = s.сharAt(5);
char n = "Good news everyone!".сharAt(5);
3) Как получить символы из строки?

Метод toCharArray возвращает массив всех символов строки.

Метод(ы)	Пример(ы)
char[]toCharArray ()
String s = "Good news everyone!";
for(char c: s.toCharArray())
{
System.out.println(c);
}
4) Как сравнить строки?

Метод equals проверяет, совпадают ли строки, а метод equalsIgnoreCase — совпадают ли строки, игнорируя регистр букв.

Метод(ы)	Пример(ы)
boolean equals (Object o)
String s = "cat";
boolean test1 = s.equals("cat");//true
boolean test2 = s.equals("Cat");//false
boolean test3 = s.equals("c"+"a"+"t");//true
boolean equalsIgnoreCase (String str)
String s = "cat";
boolean test1 = s.equalsIgnoreCase("cat");//true
boolean test2 = s.equalsIgnoreCase("Cat");//true
boolean test3 = s.equalsIgnoreCase("cAT");//true
5) Как превратить все буквы в строке в большие или маленькие?

Метод toUpperCase возвращает копию строки, все символы которой – большие.

Метод toLowerCase возвращает копию строки, все символы которой – маленькие.

Метод(ы)	Пример(ы)
String toUpperCase()
String s = "Good news everyone!";
s = s.toUpperCase();
Результат:
s == "GOOD NEWS EVERYONE!";
String toLowerCase()
String s = "Good news everyone!";
s = s.toLowerCase();
Результат:
s == "good news everyone!";
6) Как убрать пробелы в начале и в конце строки?

Метод trim возвращает копию строки, без «пустых» символов в начале и конце.

Метод(ы)	Пример(ы)
String trim()
String s = "Good news everyone!";
s = s.trim();
Результат:
s == "Good news everyone!";


7) Как получить часть строки?

Метод substring возвращает часть строки. Есть два варианта этого метода.

Первый вариант возвращает подстроку, заданную начальным и конечным номерами символов. Последний символ при этом не входит! Если передать номера (1,3) – с первого по третий, то в подстроке будут только первый и второй символы.

Второй вариант – от переданного номера и до конца строки.

Метод(ы)	Пример(ы)
String substring(int beginIndex, int endIndex)
String s = "Good news everyone!";
s = s.substring(1,6);
Результат:
s == "ood n";
String substring(int beginIndex)
String s = "Good news everyone!";
s = s.substring(1);

Как ты уже наверное знаешь – String – это immutable класс. И какие же преимущества это дало? Одно из ключевых преимуществ – это как раз получение подстроки. Но обо всем по порядку.

Внутри объект типа String содержит массив символов, о чем не трудно было догадаться. Но кроме этого там хранятся еще две переменные – номер первого символа в массиве и их количество.
Для чего они нужны, я сейчас и расскажу.

Когда мы создаем подстроку с помощью метода substring, то создается новый объект String.

Но вместо того, чтобы хранить ссылку на массив с новым набором символов, этот объект хранит ссылку на старый массив символов и вместе с этим хранит две переменные,
с помощью которых определяет – какая часть оригинального массива символов относится к нему.

— Когда создается подстрока, массив символов не копируется в новый объект String. Вместо этого оба объекта хранят ссылку на один и тот же массив символов.
Но! Второй объект хранит еще две переменных, в который записано с какого и сколько символов этого массива – его.

Вот смотри:

Получение подстроки	Что хранится внутри подстроки
String s = "mama";
Что хранится в s:
char[] value = {'m','a','m','a'};
offset = 0;
count = 4;
Strins s2 = s.substring(1);
Что хранится в s2:
char[] value = {'m','a','m','a'};
offset = 1;
count = 3;
Strins s3 = s.substring(1, 3);
Что хранится в s3:
char[] value = {'m','a','m','a'};
offset = 1;
count = 2;
Все три строки хранят ссылку на один и тот же массив char, просто кроме этого они еще хранят номер первого и последнего символа этого массива, который относится непосредственно к их объекту.
Вернее, номер первого символа и количество.

— Поэтому, если ты возьмешь строку длинной 10,000 символов и наделаешь из нее 10,000 подстрок любой длины, то эти «подстроки» будут занимать очень мало памяти, т.к. массив символов не дублируется.
Строки, которые должны занимать кучу места, будут занимать буквально пару байт.

8) Как найти нужную подстроку в строке?

Методы indexOf, lastIndexOf позволяют искать строки в строках. Есть 4 вида таких методов:

Метод indexOf ищет в нашей строке указанную строку. Он может искать ее с начала строки или начиная с какого-то номера (второй метод).
Если строка найдена – метод возвращает номер ее первого символа, если не найдена — возвращает -1

Метод(ы)	Пример(ы)
int indexOf(String str)
String s = "Good news everyone!";
int index = s.indexOf ("ne");
Результат:
index == 5
int indexOf(String str, int from)
String s = "Good news everyone!";
int index = s.indexOf ("ne",7);
Результат:
index == 16
Метод lastIndexOf ищет указанную строку в нашей строке с конца! Он может искать ее с самого конца строки или начиная с какого-то номера (второй метод).
Если строка найдена – метод возвращает номер ее первого символа, если не найдена — возвращает -1.

Метод(ы)	Пример(ы)
int lastIndexOf(String str)
String s = "Good news everyone!";
int index = s.lastIndexOf("ne");
Результат:
index == 16
int lastIndexOf(String str,int from)
String s = "Good news everyone!";
int index = s.lastIndexOf("ne",15);
Результат:
index == 5
9) Как заменить часть строки на другую?

Для этого есть три метода.

Метод replace заменяет все вхождения определенного символа на другой.

Метод replaceAll заменяет все вхождения одной подстроки на другую.

Метод replaceFirst заменяет первое вхождение переданной подстроки на заданную подстроку.

Метод(ы)	Пример(ы)
String replace(char oldChar, char newChar)
String s = "Good news everyone!";
String s2 = s.replace>('o', 'a');
Результат:
s2 == "Gaad news everyane!";
String replaceAll(String regex, String replacement)
String s = "Good news everyone!";
String s2 = s.replaceAll ("ne","_");
Результат:
s2 == "Good _ws everyo_!";
String replaceFirst(String regex, String replacement)
String s = "Good news everyone!";
String s2 = s.replaceFirst ("ne","_");
Результат:
s2 == "Good _ws everyone!";
Но тут нужно быть аккуратным. В двух последних методах (replaceAll&replaceFirst) в качестве строки, которую мы ищем, передается не просто строка, а регулярное выражение. Но об этом я расскажу позднее.


**********************************************

String.format.

Это статический метод класса String, но очень полезный. Но начну издалека.

Когда тебе нужно вывести в одной строке текст, содержащий значения нескольких переменных, как ты будешь это делать?

У тебя есть переменные:
String name = "Bender";
int age = 12;
String friend = "Fry";
int weight = 200;
Нужно вывести текст:
User = {name: Bender, age: 12 years, friend: Fry, weight: 200 kg. }
— Примерно так:

String name = "Bender";
int age = 12;
String friend = "Fry";
int weight = 200;

System.out.println("User = {name: "+name+", age:"+age+" years, friend: "+friend+", weight: "+weight+" kg.}");
— Не очень читаемо – не так ли?

— А по-моему – нормально.

— Но вот если имена переменных у тебя будут длинные или нужно будет вызывать методы для получения данных, будет уже не очень читаемо:

System.out.println("User = {name: "+user.getName()+", age:"+user.getAge()+" years, friend: "+user.getFriends().get(0)+", weight: "+user.getExtraInformation().getWeight()+" kg.}");
— Ну, если так, то да – не очень читаемо.

— Дело в том, что в реальных программах такое встречается очень часто, поэтому я хочу показать тебе, как можно упростить себе жизнь с помощью метода String.format.

— Да говори же скорее, что это за волшебный метод такой?

— Вот как можно записать приведенный выше код:

String text = String.format("User = {name: %s, age:%d years, friend: %s, weight:%d kg.}",
user.getName(), user.getAge(), user.getFriends().get(0), user.getExtraInformation().getWeight())

System.out.println(text);
В метод String.format первым параметром передается строка-шаблон, в которой, на местах, в которые мы хотим подставить значения, стоят специальные символы: %s, %d.

После строки-шаблона передаются параметры, значения которых и будут подставлены на место символов %s, %d.

Если нужно подставить строку мы пишем %s, если число — %d.

Вот тебе пример попроще:

Пример
String s = String.format("a=%d, b=%d, c=%d", 1, 4, 3);
Результат:
s будет равна «a=1, b=4, c=3»
— Да, это очень удобно.

— А ведь еще можно делать и так:

Пример
 int a = -1, b = 4, c = 3;
String template;
 if (a<0)
  template = "Warning! a=%d, b=%d, c=%d";
 else
  template = "a=%d, b=%d, c=%d";

System.out.println(String.format(template, a, b, c) );
Результат вывода:
Warning! a=-1, b=4, c=3
— Гм. Действительно полезный метод, спасибо, Элли.

— Если ты хочешь использовать в методе format другие типы данных, то вот тебе таблица:

Обозначение	Тип
%s	String
%d	целое число: int, long, …/td>
%f	вещественное число: float, double
%b	boolean
%c	char
%t	Date
%%	Символ %
На самом деле у этих параметров еще есть свои настройки, а у них свои.

Но для начала тебе этого хватит. Если же нет – вот тебе ссылка на официальную документацию:

Ссылка на дополнительный материал - https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html

****************************
StringBuilder, StringBuffer

1) У меня есть обычная строка, я хочу сделать ее изменяемой. Как мне это сделать?

String s = "Bender";
StringBuilder s2 = new StringBuilder(s);
2) Я хочу добавить символ к текущей «изменяемой строке»?

String s = "Bender";
StringBuilder s2 = new StringBuilder(s);
s2.append("!");
3) А как преобразовать StringBuilder обратно в строку?

String s = "Bender";
StringBuilder s2 = new StringBuilder(s);
s2.append("!");
s = s2.toString();
4) А если мне нужно удалить символ?

String s = "Bender";
StringBuilder s2 = new StringBuilder(s);
s2.deleteCharAt(2); //останется "Beder"
5) Я хочу заменить часть строки на другую?

String s = "Bender";
StringBuilder s2 = new StringBuilder(s);
s2.replace (3, 5, "_DE_"); //будет "Ben_DE_r"
6) Мне нужно развернуть строку задом наперед?

String s = "Bender";
StringBuilder s2 = new StringBuilder(s);
s2.reverse(); //будет "redneB";

Есть еще один класс – StringBuffer – это аналог класса StringBuilder, только его методы объявлены как synchronized.
А значит, перед каждым вызовом такого метода, Java-машина проверяет – занят ли объект или если нет — помечает его как занятый.
После выхода из метода – «освобождает» объект. Из-за этого такие вызовы работают медленнее. Не стоит без необходимости пользоваться StringBuffer.

Но если тебе нужен изменяемый объект String, к которому будут обращаться из нескольких нитей – лучше StringBuffer тебе не найти.

**************************************
Character, кодировки

Возможно, ты где-то уже слышал, что у каждого символа есть код (число). Именно поэтому тип char считается не только символьным, но и числовым типом.

Например код символа А английского алфавита – 65. B – 66, C – 67и так далее. Свои коды есть у больших букв и у маленьких, у русских букв, у китайских (ага, много, много кодов), у цифр,
у различных символов – словом практически у всего, что можно назвать символом.

— Т.е. каждой букве или каждому символу соответствует какое-то число?

— Да, именно так.

Символ можно преобразовать в число, а число в символ. Java вообще практически не видит разницы между ними:

char c = 'A'; //код(число) буквы А – 65
c++; //Теперь с содержит число 66 – код буквы B

— Так вот, кодировкой называется набор символов и соответствующий им набор кодов. Только вот таких кодировок было придумано не одна, а достаточно много.
Это уже потом придумали общую универсальную кодировку – Unicode.

Хотя, сколько бы универсальных стандартов не придумали, от старых никто отказываться не спешит. И все получается прямо как на этой картинке:

image-ru-22-05
Вот представь, что Вася и Коля захотели самостоятельно придумать кодировки.

Вот кодировка Васи:
image-ru-22-06

А вот кодировка Коли:
image-ru-22-07

Они даже используют одни и те же символы, но коды у этих символов разные.

И вот когда строку «ABC-123» в кодировке Васи записывают в файл, туда пишется набор байт:
image-ru-22-08

А теперь этот файл хочет прочитать другая программа, которая использует кодировку Коли:

Вот что она прочитает«345-IJK»

И самое плохое то, что обычно нигде в файле тип кодировки не хранится, и разработчикам программ приходится угадывать их.

— А как их угадывать?

— Это отдельная тема. Но я хочу тебе рассказать, как работать с кодировками. Как ты уже знаешь, размер типа char в Java – два байта. И строки в Java имеют формат Unicode.

Но Java позволяет преобразовать строку в набор байт любой известной ей кодировки. Для этого есть специальные методы у класса String(!).
Так же в Java есть специальный класс Charset, который описывает конкретную кодировку.

1) Как получить список всех кодировок, с которыми Java может работать?

Для этого есть специальный статический метод availableCharsets. Этот метод возвращает набор пар (имя кодировки, объект описывающий кодировку)

SortedMap<String,Charset> charsets = Charset.availableCharsets();
У каждой кодировки есть уникальное имя, вот некоторые из них: UTF-8, UTF-16, Windows-1251, KOI8-R,…

2) Как получить текущую активную кодировку (Unicode)?

Для этого есть специальный метод defaultCharset

Charset currentCharset = Charset.defaultCharset();
3) Как преобразовать строку в определенную кодировку?

В Java на основе строки можно создать массив байт в любой известной Java кодировке:

Метод	Пример
byte[] getBytes()
String s = "Good news everyone!";
byte[] buffer = s.getBytes()
byte[] getBytes(Charset charset)
String s = "Good news everyone!";
Charset koi8 = Charset.forName("KOI8-R");
byte[] buffer = s.getBytes(koi8);
byte[] getBytes(String charsetName)
String s = "Good news everyone!";
byte[] buffer = s.getBytes("Windows-1251")
4) А как преобразовать набор байт, которые я прочитал из файла в строку, если я знаю в какой кодировке они были в файле?

Тут все еще проще – у класса String есть специальный конструктор:

Метод	Пример
String(byte bytes[])
byte[] buffer = new byte[1000];
inputStream.read(buffer);

String s = new String(buffer);
String(byte bytes[], Charset charset)
byte[] buffer = new byte[1000];
inputStream.read(buffer);

Charset koi8 = Charset.forName("KOI8-R");
String s = new String(buffer, koi8);
String(byte bytes[], String charsetName)
byte[] buffer = new byte[1000];
inputStream.read(buffer);

String s = new String(buffer, "Windows-1251");
5) А как преобразовать набор байт из одной кодировки в другую?

Есть много способов. Вот тебе один из самых простых:

Charset koi8 = Charset.forName("KOI8-R");
Charset windows1251 = Charset.forName("Windows-1251");

byte[] buffer = new byte[1000];
inputStream.read(buffer);
String s = new String(buffer, koi8);
buffer = s.getBytes(windows1251);
outputStream.write(buffer);
— Я так и думал. Спасибо за интересную лекцию, Риша.



*******************************************

Регулярные выражения, примеры
— А сейчас я расскажу тебе о регулярных выражениях. Это одновременно и сложная, и простая тема.
Чтобы досконально разобраться в регулярных выражениях может понадобиться прочитать пару-тройку нетонких книг, но научить тебя пользоваться ими я могу прямо сейчас.

Если сильно упростить, то регулярные выражения – это шаблон для строки.

Ты можешь проверить – соответствует ли некоторая строка заданному шаблону или нет. Также можно разбивать строку на части, используя символ-разделитель или строку-шаблон.

Но начнем с простого – что же такое шаблон строки?

В SQL, не в Java, при сравнении строк можно проверять – совпадает ли строка с определенным шаблоном или нет. Вот как это выглядит:

name like 'Alex%'
Тут name – это переменная, like–это команда для проверки шаблона, а ‘Alex%’ –это шаблон.

В данном случае % обозначает любую строку или подстроку.

В регулярных выражениях принято задавать ограничение не только на «количество символов», но и на «содержание символа».
Любая «маска» обычно состоит из двух (иногда больше) частей, первая из которых описывает «предпочтения» в символах, а вторая часть – их количество.

Вот тебе несколько примеров содержание символа:

Шаблон	Описание	Примеры
.	Один любой символ	1
\d	Любая цифра	7
\D	Любая нецифра	C
\s	Пробел, перенос строки, символ табуляции	‘ ‘
\S	Что угодно, кроме пробела, табуляции, переноса строки	f
[a-z]	Любая буква от a до z	z
[0-9]	Любая цифра от 0 до 9.	8
\w	Любая буква	c
\W	Любая небуква	_
— Сразу не запомню, но выглядит не очень сложно.

— Отлично, тогда еще примеры количества символов в маске:

Шаблон	Описание	Примеры
A?	Символ A встречается 0..1 раз	A
B+	Символ B встречается 1.. ? раз	BBBB
C*	Символ C встречается 0.. ? раз	CCC
D{n}	Символ D встречается n раз	DDDD, для шаблона D{4}
E{n,}	Символ E встречается n.. ? раз	EEEEEEE, для шаблона E{2,}
F{n,m}	Символ F встречается n..m раз	EEEE, для шаблона E{2,4}
— Тут вообще все очевидно.

— Ты схватываешь все просто на лету. А теперь посмотрим, как все это смотрится вместе:

Шаблон	Описание	Примеры
[a-d]?	Символы a-d встречаются 0..1 раз	a, b, c, d
[b-d,z]+	Символы b,c,d,z встречаются 1.. ? раз	b, bcdcdbdbdbdbzzzzbbzbzb, zbz
[1,7-9]*	Символы 1,7,8,9 встречаются 0.. ? раз	1, 7, 9, 9777, 111199
1{5}	Символ 1 встречается 5 раз	11111
[1,2,a,b]{2}	Символы 1,2,a,b встречаются 2 раза	11, 12, 1a, ab, 2b, bb, 22
[a,0]{2,3}	Символы a,0 встречаются 2..3 раз	aa, a0,00,0a, aaa,000, a00,0a0, a0a
— Так понятно же все.

— Да. Гм. Или я все очень хорошо объясняю или ты слишком хорошо соображаешь. Но и то, и то нам на руку.

Вот тебе еще пара новых моментов.

Т.к. регулярные выражения часто используют для поиска подстрок в строке, то в шаблон добавлены еще два символа ^ и $.

«^» — означает, что подстрока обязана включать начало строки.

«$» — означает, что подстрока обязана включать конец строки.

Примеры:

Шаблон	Строка и найденные подстроки, совпадающие с шаблоном
a{3}	aaa a  aaa a  aaa
a{3}$	aaa a aaa a  aaa
^a{3}	aaa a aaa a aaa
^a{3}$	aaa a aaa a aaa
И еще одно важное дополнение.

В регулярных выражениях символы «[ ] \ / ^ $ . | ? * + ( ) { }» имеют специальное значение. Их еще называют «управляющие символы». Поэтому просто так их использовать в строке нельзя.

Как и в Java их необходимо экранировать. Для этого, как и в Java, используется символ «\».

Если мы хотим описать, что строка должна состоять из трех символов «?», то нельзя писать так: ?{3}, т.к. символ «?» является управляющим. Надо сделать так: \?{3},
если мы хотим задать символ «\», то надо написать «\\».

— Ок, понятно.

— А теперь еще маленькая интересная новость. В java, в файлах с кодом, внутри строк символ «\» тоже нужно экранировать, т.к. он является управляющим.

— Ну да.

— Так вот, если ты попытаешься задать шаблон регулярного выражения в java внутри строки, то тебе нужно будет экранировать символ \ дважды.

Пример:

Я хочу задать маску «c:\что-угодно»
Регулярное выражение, по идее, должно выглядеть так:
один символ «с»,
двоеточие,
слеш,
точка и звездочка (для обозначения любого количества символов).Я добавил пробелов для лучшей читабельности:
c : \ .*
Но символы «\» и «.» нужно экранировать, поэтому регулярное выражение будет выглядеть так:
c :  \\\.*
Или, без пробелов
c:\\\.*
В регулярном выражении у нас должно быть три слеша (слеш – косая черта)
Поэтому регулярное выражение в java-файле будет выглядеть так:
Stringregexp = «c:\\\\\\.*»;
— Ого! Ничего себе. Буду знать.

— И если ты решил посильнее в этом разобраться, то вот тебе пара хороших ссылок:

********************************************


StringTokinizer, String.replace, String.split
— Отлично, теперь я расскажу тебе о работе со строками с помощью регулярных выражений.

Начнем мы с самого простого:

1) Как проверить, совпадает ли строка с шаблоном, заданным регулярным выражением:

Для этого есть метод matches, в который передается строка, хранящая регулярное выражение, а метод возвращает true или false.

Метод(ы)	Пример(ы)
boolean matches(String regex)
String s = "Good news everyone!";
Boolean test = s.matches("news\\.*");
Результат:
false (строка не начинается со слова news)
2) Как заменить все подстроки, заданные маской, на нужные нам?

Для этого есть два метода.

Метод replaceAll заменяет все вхождения одной подстроки на другую.

Метод replaceFirst заменяет первое вхождение переданной подстроки на заданную подстроку.

Метод(ы)	Пример(ы)
String replaceAll(String regex, String replacement)
String s = "Good news everyone!";
String s2 = s.replaceAll ("e\\.","EX");
Результат:
s2 == "Good nEXs EXEXyonEX";
String replaceFirst(String regex, String replacement)
String s = "Good news everyone!";
String s2 = s.replaceFirst("e\\.","EX");
Результат:
s2 == "Good nEXs everyone!";
3) Как разбить строку на части?

Для этого есть метод split, который принимает маску подстроки-разделителя:

Метод(ы)	Пример(ы)
String[] split(String regex)
String s = "Good news everyone!";
String[] ss = s.split("ne");
System.out.println(Arrays.toString(ss));
Результат (будет массив из трех строк):
[Good , ws everyo, !]
"Good ", "ws everyo", "!";
Есть еще один способ разбиения строки на части – с помощью класса StringTokenizer.

Этот класс не использует регулярные выражения, вместо этого в него просто передается строка, состоящая из символов-разделителей.
Преимущества этого подхода в том, что он не разбивает сразу всю строку на кусочки, а потихоньку идет от начала к концу.

Класс состоит из конструктора и двух методов. В конструктор нужно передать строку, которую мы разбиваем на части, и строку – набор символов, используемых для разделения.

Метод nextToken возвращает очередной токен – подстроку.

Метод hasMoreTokens() возвращает true, если еще остались не отданные подстроки.

Метод(ы)	Пример(ы)
boolean hasMoreTokens()

String nextToken()
String s = "Good news everyone!";

StringTokenizer tokenizer =
new StringTokenizer(s,"ne");
while (tokenizer.hasMoreTokens())
{
String token = tokenizer.nextToken();
System.out.println(token);
}
Вывод на экран будет таким:
Good
ws
v
ryo
!
Обрати внимание, что разделителем считается любой символ, переданный во второй строке в конструктор StringTokenizer.

— Да, тут тоже все понятно. Может я не сразу смогу сам написать такой код, но то, что тут происходит, мне ясно.

— Отлично, тогда будем считать, что тему ты освоил.


********************************************


Подготовка к собеседованию 2 уровень

Вопросы к собеседованиям
1	Как правильно сравнить две строки в Java?
2	Как правильно сравнить две строки в Java игнорируя регистр букв?
3	Как отсортировать список строк в алфавитном порядке?
4	В какой кодировке хранятся строки в Java?
5	Как преобразовать строку в кодировку Windows-1251?
6	Как разбить строку на отдельные слова?
7	Как развернуть строку задом наперед?
8	Что происходит, когда мы пишем «A»+»b»+»C»?
9	Что такое mutable и immutable типы?
10	Что дает типу String то, что его сделали immutable?